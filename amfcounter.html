<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>A Radical AMF Colonization Counter</title>
  <link href="https://fonts.googleapis.com/css2?family=Lobster&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#ffffff; --text:#56684c; --box:#f4f4f6; --border:#d0d0d6;
}
body.dark{ --bg:#07070a; --text:#eee; --box:#121216; --border:#333; }
body{ background:var(--bg); color:var(--text); font-family:Inter,Segoe UI,Arial,sans-serif; margin:0; padding:18px; transition:background .2s,color .2s; }
header{ display:flex; flex-wrap:wrap; align-items:center; gap:16px; margin-bottom:12px; }
h1{ font-size:28px; margin:0; font-family:'Lobster', cursive; }
.toolbar{ display:flex; gap:8px; flex-wrap:wrap; margin-left:auto; }
button{ background:var(--box); color:var(--text); border:1px solid var(--border); padding:8px 10px; border-radius:8px; cursor:pointer; }
button:active{ transform:translateY(1px); }
#totalCountContainer{ margin:10px 0; }
#totalCount{ font-weight:600; }
#timeInfo{ font-size:14px; color:gray; margin-top:4px; }
#controlsRow{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
#counters{ display:block; }
.counter-box{ width:200px; border:1px solid var(--border); border-radius:10px; padding:12px; margin:10px; display:inline-block; vertical-align:top; box-sizing:border-box; }
.counter-top{ display:flex; justify-content:space-between; align-items:center; gap:8px; }
.counter-name{ width:100%; padding:6px; border:1px solid var(--border); border-radius:6px; background:transparent; color:inherit; }
.counter-box, .counter-box * { color: inherit; }
.key-label{ font-size:12px; color:gray; margin-top:6px; }
.btn-row{ display:flex; gap:8px; margin-top:10px; }
.small{ padding:6px 8px; font-size:14px; }
#minimalModeContainer{ display:none; gap:12px; flex-wrap:wrap; align-items:flex-start; padding-top:6px; }
.minimal-box{ width:140px; min-height:72px; border-radius:10px; display:flex; flex-direction:column; align-items:center; justify-content:center; padding:10px; box-sizing:border-box; cursor:pointer; user-select:none; }
.minimal-label{ font-size:13px; margin-bottom:6px; text-align:center; word-break:break-word; }
.minimal-number{ font-size:28px; font-weight:700; }
.empty-slot{ width:140px; height:72px; border-radius:10px; border:1px dashed var(--border); display:flex;align-items:center;justify-content:center;color:gray; }
.drag-hint{ font-size:12px; color:gray; margin-left:6px; }
.add-delete{ display:flex; gap:6px; margin-top:8px; }
.danger{ border-color:#e08a8a; }
table{ border-collapse:collapse; margin-top:12px; width:100%; max-width:1200px; }
th,td{ border:1px solid var(--border); padding:4px 8px; text-align:center; }
th{ background:var(--box); }
@media(max-width:800px){ .counter-box{ width:200px; } }
@media(max-width:520px){ .counter-box{ width:200px; } .minimal-box{ width:48%; } }
</style>
</head>
<body>

<header>
  <div>
    <h1>A Radical AMF Colonization Counter</h1>
    <div class="meta" id="keyDisplayMeta">Keys: ` 1 2 3 4 Q W E R A S D F Z X C V </div>
  </div>
  <div class="toolbar">
    <select id="keyPresetSelect" style="padding:6px 8px; border-radius:8px; border:1px solid var(--border); background:var(--box); color:var(--text); cursor:pointer;">
      <option value="Four Rows of Four">Four Rows of Four</option>
      <option value="Q through M">Q through M</option>
      <option value="Function Keys (F1-3)">Function Keys (F1-3)</option>
      <option value="Choose Your Own">Choose Your Own</option>
    </select>
    <select id="templateSelect" style="padding:6px 8px; border-radius:8px; border:1px solid var(--border); background:var(--box); color:var(--text); cursor:pointer;">
      <!-- templates populated dynamically -->
    </select>
    <button id="toggleModeBtn">Toggle Minimal Mode</button>
    <button id="saveScoreBtn">Save Score</button>
    <button id="pauseTimerBtn">Pause Timer</button>
    <div style="position:relative; display:inline-block;">
      <button id="settingsMenuBtn" style="padding:8px 10px; border-radius:8px;">⚙ Settings</button>
      <div id="settingsDropdown" style="display:none; position:absolute; top:100%; right:0; background:var(--box); border:1px solid var(--border); border-radius:8px; min-width:200px; box-shadow:0 2px 8px rgba(0,0,0,0.2); z-index:100; margin-top:4px;">
        <button id="resetCountersBtn" style="width:100%; text-align:left; border:none; background:transparent; padding:10px 12px; cursor:pointer; border-bottom:1px solid var(--border);">Reset Counters</button>
        <button id="saveTemplateBtn" style="width:100%; text-align:left; border:none; background:transparent; padding:10px 12px; cursor:pointer; border-bottom:1px solid var(--border);">Save Template</button>
        <button id="deleteTemplateBtn" style="width:100%; text-align:left; border:none; background:transparent; padding:10px 12px; cursor:pointer; border-bottom:1px solid var(--border);">Delete Template</button>
        <button id="exportCsvBtn" style="width:100%; text-align:left; border:none; background:transparent; padding:10px 12px; cursor:pointer; border-bottom:1px solid var(--border);">Export CSV</button>
        <button id="clearHistoryBtn" style="width:100%; text-align:left; border:none; background:transparent; padding:10px 12px; cursor:pointer; border-bottom:1px solid var(--border);">Clear Score History</button>
        <button id="toggleDarkBtn" style="width:100%; text-align:left; border:none; background:transparent; padding:10px 12px; cursor:pointer;">Toggle Dark Mode</button>
        <button id="playMoonBtn" style="width:100%; text-align:left; border:none; background:transparent; padding:10px 12px; cursor:pointer;"title="Play the Moon Beam melody" onclick="playMilestoneSound()">Play Moon Beam</button>
        <button id="playMajorBtn" style="width:100%; text-align:left; border:none; background:transparent; padding:10px 12px; cursor:pointer;"title="Play the Festival melody" onclick="playMajorMilestoneSound()">Play Festival</button>
      </div>
    </div>
  </div>
</header>

<div id="totalCountContainer">
  <div id="totalCount">Total: 0</div>
  <div id="timeInfo">Waiting to begin…</div>
</div>

<div id="controlsRow">
  <div>
    <button id="addCounterBtn">Add Counter</button>
    <button id="deleteCounterBtn">Delete Last</button>
    <span class="drag-hint">Drag to reorder (only when Minimal Mode is OFF)</span>
  </div>
</div>

<div id="counters"></div>
<div id="minimalModeContainer"></div>

<div id="historyContainer">
  <h3>Saved Scores</h3>
  <table id="historyTable">
    <thead><th></th></tr></thead>
    <tbody></tbody>
  </table>
</div>

<footer style="margin-top:40px; padding-top:20px; border-top:1px solid var(--border); color:gray; font-size:13px; text-align:center;">
  <p>Widget created to make scoring roots, or anything, possible with the use of a QWERTY Keyboard.</p>
</footer>

<script>
/* =======================
   Config & State
======================= */
const KEY_PRESETS = {
  "Four Rows of Four": ["`","1","2","3","Q","W","E","R","A","S","D","F","Z","X","C","V"],
  "Q through M": ["Q","W","E","R","T","Y","U","I","O","P","A","S","D","F","G","H","J","K","L","Z","X","C","V","B","N","M"],
  "Function Keys (F1-3)": ["F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12","`","1","2","3","4"]
};
let KEY_ORDER = KEY_PRESETS["Four Rows of Four"];
// Allow up to 30 counters (previously limited to the current key preset length)
const MAX_COUNTERS = 30;
const DEFAULT_COUNTERS = [
  { name: "No_Fungus", color: "#562929" }, // Brick Red
  { name: "AM_Hyphae", color: "#0d0d87" },
  { name: "DSE", color: "#6d4218" },
  { name: "LSE", color: "#6d4218" },
  { name: "Arbuscule", color: "#0d0d87" }, // default neutral
  { name: "Vesicle", color: "#0d0d87" },
  { name: "Coil", color: "#0d0d87" },
  { name: "DSE_and_AM", color: "#9e679e" },
  { name: "Ves_and_Arb", color: "#0d0d87" },
  { name: "Olpidium", color: "#432c54" },
  { name: "Microsclerotia", color: "#6d4218" },
  { name: "Extra_Structures", color: "#f4f4f6" },
  { name: "Mold", color: "#432c54" },
  { name: "Plasmodiophorids", color: "#432c54" },
  { name: "Root_Rot", color: "#432c54" },
  { name: "Fine_endo", color: "#0d0d87" }
];
const STORAGE_KEY = "radical_AMF_counter_v2";
const TEMPLATE_KEY = "radical_AMF_templates_v2";
const HISTORY_KEY = "radical_AMF_history_v2";
const CUSTOM_KEY_PRESETS_KEY = "radical_AMF_custom_key_presets_v1";

let state = {
  counters: [],
  minimalMode: false,
  dark: false,
  sessionStartTime: null,
  sessionEndTime: null,
  paused: false,
  keyPreset: "Four Rows of Four",
  milestoneReached: false,
  majorMilestoneReached: false
};

/* =======================
   Load/Save State
======================= */
function loadState(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if(raw){
    try{
      const parsed = JSON.parse(raw);
      if(parsed && Array.isArray(parsed.counters)){
        state = Object.assign(state, parsed);
        // Load KEY_ORDER from preset (built-in or custom)
        if(state.keyPreset.startsWith("custom:")){
          const customName = state.keyPreset.substring(7);
          const customPreset = getCustomKeyPresetByName(customName);
          if(customPreset){
            KEY_ORDER = customPreset.keys;
          } else {
            KEY_ORDER = KEY_PRESETS["Four Rows of Four"];
            state.keyPreset = "Four Rows of Four";
          }
        } else {
          KEY_ORDER = KEY_PRESETS[state.keyPreset] || KEY_PRESETS["Four Rows of Four"];
        }
        document.getElementById("keyPresetSelect").value = state.keyPreset;
        document.getElementById("keyDisplayMeta").textContent = "Keys: " + KEY_ORDER.join(" ");
        return;
      }
    }catch(e){ }
  }
  state.counters = DEFAULT_COUNTERS.map(c => ({ name: c.name, value: 0, color: c.color || "" }));
  KEY_ORDER = KEY_PRESETS[state.keyPreset];
  saveState();
}
function saveState(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

/* =======================
   Templates
======================= */
function loadTemplates(){ const raw=localStorage.getItem(TEMPLATE_KEY); return raw?JSON.parse(raw):[]; }
function saveTemplate(name){
  if(!name) return;
  const templates=loadTemplates();
  const entry = { name: name, counters: state.counters.map(c=>({ name: c.name, color: c.color || "" })) };
  const idx = templates.findIndex(t=>t.name===name);
  if(idx!==-1){
    templates[idx]=entry; // overwrite existing
  } else {
    templates.push(entry);
  }
  localStorage.setItem(TEMPLATE_KEY, JSON.stringify(templates));
  renderTemplates();
  alert(`Template "${name}" saved.`);
}
function loadTemplate(name){
  const templates=loadTemplates();
  const t=templates.find(x=>x.name===name);
  if(!t) return;
  // Each entry is {name, color}
  state.counters = t.counters.map(entry => ({ name: entry.name, value: 0, color: entry.color || "" }));
  state.sessionStartTime=null;
  state.sessionEndTime=null;
  saveState(); render();
}

// Populate the templates dropdown
function renderTemplates(){
  const select = document.getElementById("templateSelect");
  if(!select) return;
  const templates = loadTemplates();
  select.innerHTML = "";

  // Always offer the built-in default template as the first option
  const defaultOpt = document.createElement('option');
  defaultOpt.value = "__default__";
  defaultOpt.textContent = "Select Template";
  select.appendChild(defaultOpt);

  if(!templates || !templates.length){
    const opt = document.createElement('option'); opt.value=""; opt.textContent="(no saved templates)"; opt.disabled = true; select.appendChild(opt);
    return;
  }
  templates.forEach(t=>{
    const opt = document.createElement('option'); opt.value=t.name; opt.textContent=t.name; select.appendChild(opt);
  });
}

/* =======================
   Custom Key Presets
======================= */
function loadCustomKeyPresets(){
  const raw = localStorage.getItem(CUSTOM_KEY_PRESETS_KEY);
  return raw ? JSON.parse(raw) : [];
}
function saveCustomKeyPreset(name, keys){
  if(!name || !keys || !keys.length) return;
  const presets = loadCustomKeyPresets();
  const idx = presets.findIndex(p => p.name === name);
  if(idx !== -1){
    presets[idx] = { name, keys };
  } else {
    presets.push({ name, keys });
  }
  localStorage.setItem(CUSTOM_KEY_PRESETS_KEY, JSON.stringify(presets));
  updateKeyPresetDropdown();
}
function getCustomKeyPresetByName(name){
  const presets = loadCustomKeyPresets();
  return presets.find(p => p.name === name);
}
function deleteCustomKeyPreset(name){
  const presets = loadCustomKeyPresets();
  const filtered = presets.filter(p => p.name !== name);
  localStorage.setItem(CUSTOM_KEY_PRESETS_KEY, JSON.stringify(filtered));
  updateKeyPresetDropdown();
}
function updateKeyPresetDropdown(){
  const select = document.getElementById("keyPresetSelect");
  if(!select) return;
  // Store current built-in options
  const builtInOptions = ["Four Rows of Four", "Q through M", "Function Keys (F1-3)", "Choose Your Own"];
  const currentValue = select.value;
  select.innerHTML = "";
  // Add built-in options
  builtInOptions.forEach(optVal => {
    const opt = document.createElement("option");
    opt.value = optVal;
    opt.textContent = optVal;
    select.appendChild(opt);
  });
  // Add custom presets
  const customPresets = loadCustomKeyPresets();
  if(customPresets.length > 0){
    const divider = document.createElement("option");
    divider.disabled = true;
    divider.textContent = "─ Custom Presets ─";
    select.appendChild(divider);
    customPresets.forEach(preset => {
      const opt = document.createElement("option");
      opt.value = `custom:${preset.name}`;
      opt.textContent = `${preset.name} (${preset.keys.length} keys)`;
      select.appendChild(opt);
    });
  }
  select.value = currentValue;
}

/* =======================
   History
======================= */
function addHistory(score){
  const hist=JSON.parse(localStorage.getItem(HISTORY_KEY)||"[]");
  hist.push(score);
  localStorage.setItem(HISTORY_KEY, JSON.stringify(hist));
  renderHistory();
}
function getHistory(){ return JSON.parse(localStorage.getItem(HISTORY_KEY)||"[]"); }
function clearHistory(){ if(confirm("Clear all saved scores?")){ localStorage.removeItem(HISTORY_KEY); renderHistory(); } }

/* =======================
   Rendering
======================= */
const countersDiv = document.getElementById("counters");
const minimalDiv = document.getElementById("minimalModeContainer");
const totalCountEl = document.getElementById("totalCount");
const timeInfoEl = document.getElementById("timeInfo");
const historyTbody = document.querySelector("#historyTable tbody");

function playMilestoneSound(){
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const now = ctx.currentTime;
  
  // moon beam
  const notes = [
    { freq: 659.26, duration: 0.72 },  // E5 how
    { freq: 587.32, duration: 0.32 },  // D5 do
    { freq: 523.26, duration: 0.32 },  // C5 you
    { freq: 493.88, duration: 0.40 },  // B4 hold
    { freq: 440.00, duration: 0.40 },  // A4 a
    { freq: 660.00, duration: 0.64 },  // E5 moon
    { freq: 588.00, duration: 0.48 },  // D5 beam
    { freq: 524.00, duration: 0.32 },  // C5 in
    { freq: 588.00, duration: 0.24 },  // D5 your
    { freq: 524.00, duration: 1.00 },  // C5 hand
  // Final phrase - arpeggio
    { freq: 524.00, duration: 0.01 },  // C5 
    { freq: 588.00, duration: 0.01 },  // D5
    { freq: 524.00, duration: 0.01 },  // C5 
    { freq: 588.00, duration: 0.01 },  // D5
    { freq: 524.00, duration: 0.01 },  // C5 
    { freq: 588.00, duration: 0.01 },  // D5
    { freq: 523, duration: 0.3 },  // C
    { freq: 392, duration: 0.3 },  // G
    { freq: 330, duration: 0.3 },  // E
    { freq: 524, duration: 0.5 }   // C (final, held long)
];
  
  const gain = ctx.createGain();
  gain.connect(ctx.destination);
  // Increase initial gain so the melody is louder (user requested higher volume)
  gain.gain.setValueAtTime(1.5, now);
  
  let time = now;
  notes.forEach(note => {
    const osc = ctx.createOscillator();
    osc.connect(gain);
    osc.frequency.value = note.freq;
    osc.type = "sine";
    osc.start(time);
    osc.stop(time + note.duration);
    time += note.duration;
  });
  
}

function playMajorMilestoneSound(){
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const now = ctx.currentTime;
  
  // Create a longer Melody, The Festival
  const notes = [
    // First phrase - ascending
    { freq: 494, duration: 0.4 },  // B4
    { freq: 523, duration: 0.4 },  // C5
    { freq: 523, duration: 0.2 },  // C5
    { freq: 494, duration: 0.2 },  // B4
    { freq: 523, duration: 0.2 },  // C5
    { freq: 494, duration: 0.2 },  // B4
    { freq: 659.26, duration: 0.4 },  // E5
    { freq: 523, duration: 0.2 },  // C5)
    { freq: 349, duration: 0.4 },  // F4
    // Second phrase - descending with variation
    { freq: 494, duration: 0.4 },  // B4
    { freq: 523, duration: 0.4 },  // C5
    { freq: 523, duration: 0.2 },  // C5
    { freq: 494, duration: 0.2 },  // B4
    { freq: 523, duration: 0.2 },  // C5
    { freq: 494, duration: 0.2 },  // B4
    { freq: 659.26, duration: 0.4 },  // E5
    { freq: 523, duration: 0.2 },  // C5
    { freq: 349, duration: 1.4 },  // F4
    // Third phrase - triumphant
    { freq: 523, duration: 0.4 },  // C5
    { freq: 494, duration: 0.2 },  // B4
    { freq: 659.26, duration: 1.4 },  // E5 (high)
    // Final phrase - arpeggio
    { freq: 494, duration: 0.2 },  // B4
    { freq: 523, duration: 0.4 },  // C5
    { freq: 440, duration: 0.3 },  // A4
    { freq: 523, duration: 0.3 },  // C (high)
    { freq: 587, duration: 0.3 },  // D
    { freq: 523, duration: 0.3 },  // C
    { freq: 392, duration: 0.3 },  // G
    { freq: 330, duration: 0.3 },  // E
    { freq: 262, duration: 2.5 }   // C (final, held long)
  ];
  
  const gain = ctx.createGain();
  gain.connect(ctx.destination);
  gain.gain.setValueAtTime(2, now);
  
  let time = now;
  notes.forEach(note => {
    const osc = ctx.createOscillator();
    osc.connect(gain);
    osc.frequency.value = note.freq;
    osc.type = "sine";
    osc.start(time);
    osc.stop(time + note.duration);
    time += note.duration;
  });
  
}

function enterCustomKeyMode(){
  const modal = document.createElement("div");
  modal.style.cssText = "position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);display:flex;justify-content:center;align-items:center;z-index:9999;";
  
  const container = document.createElement("div");
  container.style.cssText = "background:var(--box);color:var(--text);padding:24px;border-radius:12px;max-width:500px;width:90%;box-shadow:0 4px 12px rgba(0,0,0,0.3);";
  
  const title = document.createElement("h3");
  title.textContent = "Choose Custom Key Bindings";
  title.style.marginTop = "0";
  container.appendChild(title);
  
  const instruction = document.createElement("p");
  instruction.style.fontSize = "14px";
  instruction.style.color = "gray";
  instruction.textContent = `Press each key in order for the ${state.counters.length} counters below. Press Enter when done.`;
  container.appendChild(instruction);
  
  const countersList = document.createElement("div");
  countersList.style.cssText = "margin-bottom:16px;max-height:200px;overflow-y:auto;";
  
  let capturedKeys = [];
  let currentIndex = 0;
  
  function updateDisplay(){
    countersList.innerHTML = "";
    state.counters.forEach((counter, idx) => {
      const row = document.createElement("div");
      row.style.cssText = "padding:8px;margin:4px 0;border-radius:6px;border:1px solid var(--border);";
      if(idx < capturedKeys.length){
        row.style.background = "var(--box)";
        row.textContent = `${counter.name}: ${capturedKeys[idx]}`;
      } else if(idx === capturedKeys.length){
        row.style.background = "#4a7d3a";
        row.textContent = `${counter.name}: (waiting for key...)`;
      } else {
        row.style.opacity = "0.5";
        row.textContent = `${counter.name}: (pending)`;
      }
      countersList.appendChild(row);
    });
  }
  
  updateDisplay();
  container.appendChild(countersList);
  
  const presetNameInput = document.createElement("input");
  presetNameInput.type = "text";
  presetNameInput.placeholder = "Preset name (e.g., 'My Custom Keys')";
  presetNameInput.style.cssText = "width:100%;padding:8px;margin-bottom:12px;border:1px solid var(--border);border-radius:6px;background:var(--bg);color:var(--text);box-sizing:border-box;";
  presetNameInput.disabled = true;
  container.appendChild(presetNameInput);
  
  const buttonRow = document.createElement("div");
  buttonRow.style.cssText = "display:flex;gap:8px;justify-content:flex-end;";
  
  const cancelBtn = document.createElement("button");
  cancelBtn.textContent = "Cancel";
  cancelBtn.style.cssText = "padding:8px 16px;border-radius:6px;border:1px solid var(--border);background:var(--box);color:var(--text);cursor:pointer;";
  cancelBtn.onclick = () => modal.remove();
  buttonRow.appendChild(cancelBtn);
  
  const saveBtn = document.createElement("button");
  saveBtn.textContent = "Save Preset";
  saveBtn.style.cssText = "padding:8px 16px;border-radius:6px;border:1px solid var(--border);background:#4a7d3a;color:#fff;cursor:pointer;";
  saveBtn.disabled = true;
  saveBtn.onclick = () => {
    const presetName = presetNameInput.value.trim();
    if(!presetName){
      alert("Please enter a preset name.");
      return;
    }
    if(capturedKeys.length !== state.counters.length){
      alert(`You need to capture ${state.counters.length} keys.`);
      return;
    }
    // Store the preset in localStorage directly without calling updateKeyPresetDropdown yet
    const presets = loadCustomKeyPresets();
    const idx = presets.findIndex(p => p.name === presetName);
    if(idx !== -1){
      presets[idx] = { name: presetName, keys: capturedKeys };
    } else {
      presets.push({ name: presetName, keys: capturedKeys });
    }
    localStorage.setItem(CUSTOM_KEY_PRESETS_KEY, JSON.stringify(presets));
    
    // Update state
    state.keyPreset = `custom:${presetName}`;
    KEY_ORDER = capturedKeys;
    document.getElementById("keyDisplayMeta").textContent = "Keys: " + KEY_ORDER.join(" ");
    saveState();
    
    // Remove modal first
    modal.remove();
    
    // Then update dropdown and render
    updateKeyPresetDropdown();
    document.getElementById("keyPresetSelect").value = state.keyPreset;
    render();
  };
  buttonRow.appendChild(saveBtn);
  container.appendChild(buttonRow);
  
  modal.appendChild(container);
  document.body.appendChild(modal);
  
  // Key capture handler
  function keyHandler(e){
    // Ignore certain keys
    if(['Enter','Escape','Control','Alt','Shift','Meta','ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Tab'].includes(e.key)){
      if(e.key === 'Enter' && capturedKeys.length === state.counters.length){
        e.preventDefault();
        presetNameInput.disabled = false;
        saveBtn.disabled = false;
        presetNameInput.focus();
        window.removeEventListener("keydown", keyHandler);
      } else if(e.key === 'Escape'){
        e.preventDefault();
        window.removeEventListener("keydown", keyHandler);
        modal.remove();
      }
      return;
    }
    e.preventDefault();
    if(capturedKeys.length < state.counters.length){
      const key = e.key.toUpperCase();
      if(!capturedKeys.includes(key)){
        capturedKeys.push(key);
        updateDisplay();
      } else {
        alert(`Key "${key}" already used. Pick a different key.`);
      }
    }
  }
  
  window.addEventListener("keydown", keyHandler);
  modal.focus();
}

function updateTotal(){
  // Counters whose names indicate 'extra' or 'intersection' should subtract from the total

  function isNegativeCounter(name){
    if(!name) return false;
    const n = String(name).toLowerCase().replace(/[^a-z0-9]+/g,' ');
    return /\b(extra|intersection)\b/.test(n);
  }

  const positive = state.counters.reduce((s,c)=> s + (isNegativeCounter(c.name)?0:(Number(c.value)||0)), 0);
  const negative = state.counters.reduce((s,c)=> s + (isNegativeCounter(c.name)?(Number(c.value)||0):0), 0);
  const total = positive - negative;
  totalCountEl.textContent = `Total: ${total}`;

  if(total === 150 && !state.majorMilestoneReached){
    state.majorMilestoneReached = true;
    playMajorMilestoneSound();
  } else if(total === 100 && !state.milestoneReached){
    state.milestoneReached = true;
    playMilestoneSound();
  } else if(total < 100){
    state.milestoneReached = false;
  } else if(total < 150){
    state.majorMilestoneReached = false;
  }
}
function speak(text){
  if(!("speechSynthesis" in window)) return;
  // Replace underscores with spaces so the synthesizer doesn't read them aloud as "underscore"
  const processedText = String(text).replace(/_/g, ' ').replace(/\s+/g, ' ').trim();
  const msg = new SpeechSynthesisUtterance(processedText);

  // Helper: pick a preferred British (en-GB) / UK voice and prefer common female names
  function selectPreferredVoice(){
    const voices = speechSynthesis.getVoices() || [];
    if(!voices.length) return null;

    const femaleNamePattern = /fiona|eilidh|sophie|molly|ava|amelia|victoria|samantha|katherine|kathleen|laura|emily|claire/i;
    // 1) prefer female-sounding known names
    let voice = voices.find(v => femaleNamePattern.test(v.name));
    if(voice) return voice;

    // 2) prefer en-GB / UK voices by language tag or name
    voice = voices.find(v => /en-?gb|en-?uk/i.test(v.lang) || /uk|great britain|united kingdom|british/i.test(v.name));
    if(voice) return voice;

    // 3) fallback to any English voice
    voice = voices.find(v => /^en/i.test(v.lang));
    if(voice) return voice;

    // 4) final fallback: first available voice
    return voices[0] || null;
  }

  // If we already cached a preferred voice, use it
  if(window._preferredVoice){ msg.voice = window._preferredVoice; }
  else {
    const v = selectPreferredVoice();
    if(v){ window._preferredVoice = v; msg.voice = v; }
  }

  // If voices aren't loaded yet, wait for them and then speak once available
  const loadedVoices = speechSynthesis.getVoices();
  if(!loadedVoices || !loadedVoices.length){
    const handler = () => {
      window._preferredVoice = selectPreferredVoice();
      if(window._preferredVoice) msg.voice = window._preferredVoice;
      speechSynthesis.speak(msg);
      speechSynthesis.removeEventListener('voiceschanged', handler);
    };
    speechSynthesis.addEventListener('voiceschanged', handler);
    return;
  }

  speechSynthesis.cancel();
  speechSynthesis.speak(msg);
}
function formatTime(ms){
  if(ms<=0) return "00:00:00";
  const sec = Math.floor(ms/1000);
  const h = Math.floor(sec/3600);
  const m = Math.floor((sec%3600)/60);
  const s = sec%60;
  return [h,m,s].map(x=>x.toString().padStart(2,"0")).join(":");
}
function updateTimer(){
  if(!state.sessionStartTime){ timeInfoEl.textContent="Waiting to begin…"; return; }
  const now = state.paused ? state.sessionEndTime : Date.now();
  const elapsed = now - state.sessionStartTime;
  timeInfoEl.textContent = `Elapsed: ${formatTime(elapsed)}`;
}

/* Text color for contrast on bg color */
function textColorForBg(hex){
  if(!hex) return "";
  const c=parseInt(hex.slice(1),16);
  const r=(c>>16)&255, g=(c>>8)&255, b=c&255;
  const brightness = r*0.299 + g*0.587 + b*0.114;

  // If dark mode, invert the usual logic for very light colors
  if(document.body.classList.contains("dark")){
    return brightness > 200 ? "#111" : "#eee"; // very bright bg -> dark text
  } else {
    return brightness > 186 ? "#111" : "#eee";
  }
}


/* Render full mode */
function renderFull(){
  countersDiv.innerHTML="";
  state.counters.forEach((c,idx)=>{
    const box=document.createElement("div");
    box.className="counter-box";
    box.draggable=true;
    box.dataset.index=idx;
    box.style.backgroundColor=c.color||"var(--box)";
    box.style.color=textColorForBg(c.color||"#f4f4f6");

    // Drag & drop
    box.addEventListener("dragstart",e=>{ e.dataTransfer.setData("text/plain",String(idx)); box.style.opacity="0.5"; });
    box.addEventListener("dragend",e=>{ box.style.opacity=""; });
    box.addEventListener("dragover",e=>{ e.preventDefault(); });
    box.addEventListener("drop",e=>{
      e.preventDefault();
      const from=Number(e.dataTransfer.getData("text/plain"));
      const to=idx;
      if(isNaN(from)) return;
      const item=state.counters.splice(from,1)[0];
      state.counters.splice(to,0,item);
      saveState();
      render();
    });

    box.innerHTML=`
      <div class="counter-top">
        <input class="counter-name" data-idx="${idx}" value="${c.name}" />
        <input type="color" value="${c.color||'#f4f4f6'}" data-idx="${idx}" class="counter-color-picker" title="Choose counter color"/>
      </div>
      <div style="margin-top:8px"><strong>Count:</strong> <span id="val-${idx}">${c.value||0}</span></div>
      <div class="key-label"><strong>Key:</strong> ${KEY_ORDER[idx]||"—"}</div>
      <div class="btn-row">
        <button class="small" data-action="inc" data-idx="${idx}">+1</button>
        <button class="small" data-action="dec" data-idx="${idx}">-1</button>
        <button class="small" data-action="del" data-idx="${idx}">Delete</button>
      </div>
    `;
    countersDiv.appendChild(box);
  });

  document.querySelectorAll(".counter-name").forEach(inp=>{
    inp.addEventListener("change",e=>{
      const i=Number(inp.dataset.idx);
      state.counters[i].name=inp.value.trim()||`Counter ${i+1}`;
      saveState(); render();
    });
  });
  document.querySelectorAll(".counter-color-picker").forEach(pick=>{
    pick.addEventListener("input",e=>{
      const i=Number(pick.dataset.idx);
      state.counters[i].color=pick.value;
      saveState(); render();
    });
  });
  document.querySelectorAll("button[data-action]").forEach(btn=>{
    btn.addEventListener("click",e=>{
      const i=Number(btn.dataset.idx);
      const act=btn.dataset.action;
      if(act==="inc") incrementAt(i);
      else if(act==="dec") decrementAt(i);
      else if(act==="del"){
        if(confirm(`Delete counter "${state.counters[i].name}"? Keys will shift.`)){
          state.counters.splice(i,1); saveState(); render();
        }
      }
    });
  });
}

/* Render minimal mode */
function renderMinimal(){
  minimalDiv.innerHTML="";
  minimalDiv.style.display="flex"; minimalDiv.style.flexWrap="wrap";
  state.counters.forEach((c,idx)=>{
    const tile=document.createElement("div");
    tile.className="minimal-box"; tile.dataset.idx=idx;
    tile.style.backgroundColor=c.color||"var(--box)";
    tile.style.color=textColorForBg(c.color||"#f4f4f6");
    tile.innerHTML=`<div class="minimal-label">${c.name}</div><div class="minimal-number">${c.value||0}</div><div class="meta" style="margin-top:8px">Key: ${KEY_ORDER[idx]||"—"}</div>`;
    tile.onclick=()=>incrementAt(idx);
    minimalDiv.appendChild(tile);
  });
}

/* Render history table */
function renderHistory(){
  const hist=getHistory();
  historyTbody.innerHTML="";
  if(!hist.length) return;

  // Collect all counter names across all scores
  const allNames=[...new Set(hist.flatMap(r=>Object.keys(r.counters)))];

  hist.forEach((r,i)=>{
    const tr=document.createElement("tr");
    const cells=[
      `<td>${r.sample_id}</td>`,
      ...allNames.map(n=>`<td>${r.counters[n]||0}</td>`),
      `<td>${r.start_timestamp}</td>`,
      `<td>${r.end_timestamp}</td>`,
      `<td>${r.duration_minutes||0}</td>`,
      `<td>${r.notes||""}</td>`,
      `<td><button data-idx="${i}" class="small">Delete</button></td>`
    ];
    tr.innerHTML=cells.join("");
    historyTbody.appendChild(tr);
  });

  // Update table header
  const thead=document.querySelector("#historyTable thead");
  thead.innerHTML="";
  const headerRow=["sample_id", ...allNames, "Start", "End", "Duration (min)", "Notes", "Delete"];
  thead.innerHTML="<tr>"+headerRow.map(h=>`<th>${h}</th>`).join("")+"</tr>";

  // Delete buttons
  document.querySelectorAll("#historyTable button").forEach(btn=>{
    btn.addEventListener("click",e=>{
      const i=Number(btn.dataset.idx);
      const hist=getHistory();
      if(confirm(`Delete score "${hist[i].sample_id}"?`)){
        hist.splice(i,1);
        localStorage.setItem(HISTORY_KEY,JSON.stringify(hist));
        renderHistory();
      }
    });
  });
}

/* Top-level render */
function render(){
  if(state.minimalMode){ countersDiv.style.display="none"; minimalDiv.style.display="flex"; renderMinimal(); }
  else{ minimalDiv.style.display="none"; countersDiv.style.display="block"; renderFull(); }
  updateTotal(); updateTimer();
  document.body.classList.toggle("dark",state.dark);
  renderTemplates();
  saveState(); renderHistory();
}

/* =======================
   Counter Ops
======================= */
function incrementAt(i){
  if(!state.counters[i]) return;
  if(!state.sessionStartTime) state.sessionStartTime=Date.now();
  if(!state.paused) state.sessionEndTime=Date.now();
  state.counters[i].value=(Number(state.counters[i].value)||0)+1;
  saveState(); render(); speak(`${state.counters[i].value} ${state.counters[i].name}`);
}
function decrementAt(i){ if(!state.counters[i]) return; state.counters[i].value=Math.max(0,(Number(state.counters[i].value)||0)-1); if(!state.paused) state.sessionEndTime=Date.now(); saveState(); render(); speak(`${state.counters[i].value} ${state.counters[i].name}`); }
function addCounter(){ if(state.counters.length>=MAX_COUNTERS){ alert(`Maximum ${MAX_COUNTERS} counters reached.`); return; } const idx=state.counters.length; state.counters.push({name:`Counter ${idx+1}`,value:0,color:""}); saveState(); render(); }
function deleteLast(){ if(state.counters.length===0) return; if(!confirm("Delete last counter? Keys shift.")) return; state.counters.pop(); saveState(); render(); }
function resetCounters(){
  if(!confirm("Reset all counters and session timing?")) return;
  state.counters.forEach(c=>c.value=0);
  state.sessionStartTime=null;
  state.sessionEndTime=null;
  state.paused=false;
  state.milestoneReached=false;
  saveState(); render();
}/* =======================
   Save Score
======================= */
function saveScore(){
  if(!state.sessionStartTime){ alert("No counts yet to save."); return; }
  const hist=getHistory();
  const defaultId="Score_"+(hist.length+1);
  const name = prompt("Enter Sample ID:",defaultId);
  if(!name) return;
  const notes = prompt("Add notes (optional):", "");
  const start=new Date(state.sessionStartTime).toLocaleTimeString();
  const end=new Date(state.sessionEndTime).toLocaleTimeString();
  const durationSeconds=Math.floor((state.sessionEndTime-state.sessionStartTime)/1000);
  const durationMinutes=Math.round(durationSeconds/60*100)/100;
  const countsObj={};
  state.counters.forEach(c=>countsObj[c.name]=c.value||0);
  const session={sample_id:name,counters:countsObj,notes:notes||"",start_timestamp:start,end_timestamp:end,duration_minutes:durationMinutes};
  addHistory(session);
  state.counters.forEach(c=>c.value=0); // reset
  state.sessionStartTime=null; state.sessionEndTime=null; state.paused=false;
  saveState(); render();
}

/* =======================
   Export CSV
======================= */
function exportCSV(){
  const hist=getHistory();
  if(!hist.length){ alert("No scores to export."); return; }
  const allNames=[...new Set(hist.flatMap(r=>Object.keys(r.counters)))];
  const headers=["sample_id", ...allNames,"start_timestamp","end_timestamp","duration_minutes"];
  const rows = hist.map(r=>{
    const row=[r.sample_id];
    allNames.forEach(n=>row.push(r.counters[n]||0));
    row.push(r.start_timestamp,r.end_timestamp,r.duration_minutes||0);
    return row.join(",");
  });
  const csv=[headers.join(","), ...rows].join("\n");
  const blob=new Blob([csv],{type:"text/csv"});
  const a=document.createElement("a");
  a.href=URL.createObjectURL(blob);
  const fileName=prompt("Enter filename for export:","radical_AMF_scores.csv")||"radical_AMF_scores.csv";
  a.download=fileName;
  a.click();
}

/* =======================
   Keyboard Mapping
======================= */
document.addEventListener("keydown",e=>{
  const ae=document.activeElement;
  if(ae&&(ae.tagName==="INPUT"||ae.tagName==="TEXTAREA"||ae.isContentEditable)) return;
  const key=String(e.key||"").toUpperCase();
  if(!key) return;
  const pos=KEY_ORDER.indexOf(key);
  if(pos===-1) return;
  if(pos<state.counters.length){ incrementAt(pos); e.preventDefault(); }
});

/* =======================
   Button Events
======================= */
document.getElementById("toggleModeBtn").addEventListener("click",()=>{ state.minimalMode=!state.minimalMode; render(); });
document.getElementById("resetCountersBtn").addEventListener("click",()=>resetCounters());
document.getElementById("saveScoreBtn").addEventListener("click",()=>saveScore());
document.getElementById("exportCsvBtn").addEventListener("click",()=>exportCSV());
document.getElementById("clearHistoryBtn").addEventListener("click",()=>clearHistory());
document.getElementById("toggleDarkBtn").addEventListener("click",()=>{ state.dark=!state.dark; render(); });
document.getElementById("pauseTimerBtn").addEventListener("click",()=>{
  state.paused=!state.paused;
  if(state.paused) state.sessionEndTime=Date.now();
  document.getElementById("pauseTimerBtn").textContent=state.paused?"Resume Timer":"Pause Timer";
});
document.getElementById("saveTemplateBtn").addEventListener("click",()=>{
  const defaultName = "Template_"+(loadTemplates().length+1);
  const name=prompt("Enter template name:", defaultName);
  if(!name) return;
  const existing = loadTemplates().find(t=>t.name===name);
  if(existing){
    if(!confirm(`Template "${name}" exists. Overwrite?`)) return;
  }
  saveTemplate(name);
});
// Load template when the user selects one from the dropdown
document.getElementById("templateSelect").addEventListener("change",()=>{
  const select = document.getElementById("templateSelect");
  if(!select) return;
  const name = select.value;
  if(!name){ return; }
  // Special-case the built-in default template
  if(name === "__default__"){
    if(!confirm(`Load default template? This will reset current counters.`)){
      renderTemplates();
      return;
    }
    state.counters = DEFAULT_COUNTERS.map(c => ({ name: c.name, value: 0, color: c.color || "" }));
    state.sessionStartTime = null;
    state.sessionEndTime = null;
    state.paused = false;
    saveState();
    render();
    return;
  }
  if(!confirm(`Load template "${name}"? This will reset current counters.`)){
    // revert selection to no-op (optional)
    renderTemplates();
    return;
  }
  loadTemplate(name);
});
document.getElementById("deleteTemplateBtn").addEventListener("click",()=>{
  const select = document.getElementById("templateSelect");
  if(!select) return;
  const name = select.value;
  if(!name){ alert("No template selected."); return; }
  if(!confirm(`Delete template "${name}"? This cannot be undone.`)) return;
  const templates = loadTemplates().filter(t=>t.name!==name);
  localStorage.setItem(TEMPLATE_KEY, JSON.stringify(templates));
  renderTemplates();
});

document.getElementById("addCounterBtn").addEventListener("click",()=>addCounter());
document.getElementById("deleteCounterBtn").addEventListener("click",()=>deleteLast());

document.getElementById("keyPresetSelect").addEventListener("change",e=>{
  const preset=e.target.value;
  
  if(preset === "Choose Your Own"){
    // Enter custom key binding mode
    enterCustomKeyMode();
    return;
  }
  
  if(preset.startsWith("custom:")){
    // Load a saved custom preset
    const customName = preset.substring(7);
    const customPreset = getCustomKeyPresetByName(customName);
    if(customPreset){
      state.keyPreset = preset;
      KEY_ORDER = customPreset.keys;
      document.getElementById("keyDisplayMeta").textContent = "Keys: " + KEY_ORDER.join(" ");
      saveState();
      render();
    }
    return;
  }
  
  // Load a built-in preset
  state.keyPreset=preset;
  KEY_ORDER=KEY_PRESETS[preset];
  document.getElementById("keyDisplayMeta").textContent="Keys: "+KEY_ORDER.join(" ");
  saveState();
  render();
});

/* =======================
   Settings Menu Toggle
======================= */
const settingsMenuBtn = document.getElementById("settingsMenuBtn");
const settingsDropdown = document.getElementById("settingsDropdown");

settingsMenuBtn.addEventListener("click", e => {
  e.stopPropagation();
  const isVisible = settingsDropdown.style.display !== "none";
  settingsDropdown.style.display = isVisible ? "none" : "block";
});

// Close dropdown when clicking outside
document.addEventListener("click", e => {
  if(!settingsMenuBtn.contains(e.target) && !settingsDropdown.contains(e.target)){
    settingsDropdown.style.display = "none";
  }
});

// Close dropdown after selecting an option
settingsDropdown.querySelectorAll("button").forEach(btn => {
  btn.addEventListener("click", () => {
    settingsDropdown.style.display = "none";
  });
});

/* =======================
   Init
======================= */
loadState();
updateKeyPresetDropdown(); // Populate dropdown with built-in and custom presets
// Ensure a default template exists (names + colors) so users can restore it after changes
(function ensureDefaultTemplate(){
  const templates = loadTemplates();
  if(!templates || !templates.length){
    templates.push({
      name: "Default Template",
      counters: DEFAULT_COUNTERS.map(c=>({ name: c.name, color: c.color || "" }))
    });
    localStorage.setItem(TEMPLATE_KEY, JSON.stringify(templates));
  }
})();
render();
setInterval(()=>{if(!state.paused) updateTimer();},1000);
</script>

</body>
</html>
